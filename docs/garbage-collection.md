[[toc]]

# 要解决的问题

* 如何理解高级语言的垃圾回收

# 解决方案

GC标记-清除，引用计数，GC复制算法是3个经典的垃圾回收算法，高级语言的垃圾回收策略通常是以上3个算法的组合应用和优化实现。

## 构成

| 构成 | 解释 |
| --- | --- |
| mutator | 应用程序 |
| object | 应用程序生成的动态对象。被应用程序继续引用的对象为活动对象，不再被引用的对象为非活动对象。GC过程是释放非活动对象占用的内存空间 |
| heap | 堆，存放动态对象的内存空间。垃圾回收是指回收堆中不再被 mutator 引用的空间 |
| pointer | 指针，object之间通过指针来描述引用关系 |
| root | 根，活动对象之间通过指针连接，构成一个树形结构。根用于描述树形结构的起点。通过根可以遍历（追踪）活动对象 |
| chunk | 分块，垃圾回收的基本单位。heap中有多个分块 |
| allocation | 为对象分配空闲分块的过程 |
| collection | 回收垃圾分块的过程 |

## 衍生的问题

* [如何降低垃圾回收的最大暂停时间](reduce-stw-max-time.md)
* [如何解决并发垃圾回收导致的同步问题](cms-write-barrier.md)

# 解决方案案例

## Golang 的 GC

Golang 1.5版本之后利用三色标记-清除算法实现垃圾回收。在标记阶段，存在STW。目前1.7版本之后，STW耗时已经优化到1ms。

## Python 的 GC

Python 使用引用计数算法实现垃圾回收。为了解决循环引用无法被回收的问题，python 同时使用部分标记-清除算法进行回收。

## Java 的 GC

Java 使用分代垃圾回收。将对象分成新生代、老年代，针对不同的代，使用不同的GC算法。分代垃圾回收是GC复制和标记清除算法的组合应用。